Mosi Ighzebier
1.	
a.	The class has low cohesion essentially because of the many moving parts that are not necessarily related to one another in order to complete specific tasks. The unrelation between for instance, client info, workout scheduling, scheduling workouts, and nutrition tracking make the class have multiple responsibilities and too demanding to put into one class. 
b.	These responsibilities (nutrition tracking, scheduling workouts etc.) could’ve been separated into different classes to have higher cohesion. This would allow each class to have one singular responsibility. public class workout { would be one for instance.
2.	
a.	Because one has subclasses “Student” should be an abstract class. Abstract classes allow us to establish base functionalities or implementation that can also be attributed to sub-classses but are not so grounded in that specific use-cases for instance in a ThirdYear or FirstYear class cannot be brought to life. Giving us as programmers more freedom.
b.	The above method is flawed because of the way inheritance is being utilized. Since, we have a specialization hierarchy (superclass-subclass), this method is too specific to the ThirdYear student. So, if we wanted to remove first or second years the method would not run because it is not substituting subtypes into the super but the reverse. (Cited from H5.1)
3.	
a.	No its is not well encapsulated. I would encapsulate (private) aspects of the class that are static or would not need to interpreted/modified by other classes or code in the program because these are critical aspects (data attributes) to a person’s bank account we would not want this data public allowing people to know how it is implemented into the program. So, this would private, accountNumber, interestRate, accountHolderName, and balance.
4.	
a.	The current structure does not support this because one you designate the car into its specific trim level you limit what can be done to the subclass due to inheritance. In other words, this current structure does allow you designate the car as a Luxury model and them let the customer decide they want a sports trim.
b.	To fix this problem use composition’s has-a principle with an interface to allow you to let the client dynamically change what they want because it will allow the trim to always possess independently linked properties. Specifically, you create a Trim interface which doesn’t concretize the aspects of the trims like a class would and depending on your trim designate which aspects they hold.
5.	In terms of Riel’s heuristics you want to have concise and consistent programming habits essentially. By having two classes with similar functionalities you confuse yourself as a programmer, and your readability because it can muddle which class should be referenced or when changes are made across your program. This means that in this use case you would want to establish an Inheritance system in your program by creating a base class that the then smaller parts with different code could be subclasses to fit their specific use cases.
6.	It is unwise because storing them together creates a relationship between the two which goes against the aim of low coupling as they become coupled. 
7.	The condition would be satisfied if you have certain specific aspects of your program that shares common characteristic with previously implemented aspects. “is-a” or like our Student -> firstYear/ThirdYear question.
8.	Composition describes a has-a relationship, while inheritance describes a is-a relationship. The use case depends on if the focused aspect extends and specializes from a class (inheritance) or if it refers to a contained aspect within a class. So, if I had a class House my house has a  garage so I would use composition.
9.	Cohesion has to do due with the focus of aspects in your program. High cohesion is better because it shys away from god classes allowing for feasibility in your program when making changes etc.
